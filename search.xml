<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python 爬取图片]]></title>
    <url>%2F2021%2F02%2F14%2Fpython-%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[思路分析： ​ requests 获得需要爬取的网页 ​ 将爬取的网页数据做成BeautifulSoup ​ 应用soup 的API 找到需要的标签属性 通过标签属性获得二进制字节保存 1234567891011import requestsfrom bs4 import BeautifulSoupdata.encoding = data.apparent_encodingsoup = BeautifulSoup(data.text)link = soup.select_one("#container &gt; div &gt; div &gt; div:nth-child(3) &gt; div.list_con_box &gt; div.zt_con_img &gt; dl &gt; dd &gt; ul &gt; li:nth-child(1) &gt; a &gt; img")['src']f = open("D://a.jpg","wb")pic_data = requests.get(link)f.write(pic_data.content)f.close()]]></content>
      <tags>
        <tag>是</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写数字识别]]></title>
    <url>%2F2021%2F02%2F14%2F%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[具体参考 https://www.cnblogs.com/endlesscoding/p/9901539.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120from sklearn.datasets import fetch_mldatafrom sklearn import datasetsimport numpy as np ## 样本可能下载超时mnist = fetch_mldata('mnist-original', data_home = './datasets/') mnistX, y = mnist['data'], mnist['target']print(X.shape)print(y.shape)%matplotlib inlineimport matplotlibimport matplotlib.pyplot as plt # 第一个样本some_digit = X[1]some_digit_image = some_digit.reshape(28,28) plt.imshow(some_digit_image, cmap=matplotlib.cm.binary, interpolation="nearest")plt.axis('off')plt.show()# EXTRA def plot_digits(instances, images_per_row=10, **options): size = 28 images_per_row = min(len(instances), images_per_row) images = [instance.reshape(size,size) for instance in instances] n_rows = (len(instances) - 1) // images_per_row + 1 row_images = [] n_empty = n_rows * images_per_row - len(instances) images.append(np.zeros((size, size * n_empty))) for row in range(n_rows): rimages = images[row * images_per_row : (row + 1) * images_per_row] row_images.append(np.concatenate(rimages, axis=1)) image = np.concatenate(row_images, axis=0) plt.imshow(image, cmap = matplotlib.cm.binary, **options) plt.axis("off") plt.figure(figsize=(9,9))example_images = np.r_[X[:12000:600], X[13000:30600:600], X[30600:60000:590]]plot_digits(example_images, images_per_row=10)# save_fig("more_digits_plot")plt.show()X_train, X_test, y_train, y_test = X[:60000],X[60000:],y[:60000],y[60000:]# 打乱标签import numpy as np shuffle_index = np.random.permutation(60000)X_train, y_train = X_train[shuffle_index],y_train[shuffle_index]# 训练一个二分器# 这是一个逻辑数组，5：True, 非5：Falsey_train_5 = (y_train == 5)y_test_5 = (y_test == 5)from sklearn.linear_model import SGDClassifier sgd_clf = SGDClassifier(random_state = 32)sgd_clf.fit(X_train, y_train_5)SGDClassifier(alpha=0.0001, average=False, class_weight=None, early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True, l1_ratio=0.15, learning_rate='optimal', loss='hinge', max_iter=None, n_iter=None, n_iter_no_change=5, n_jobs=None, penalty='l2', power_t=0.5, random_state=32, shuffle=True, tol=None, validation_fraction=0.1, verbose=0, warm_start=False)sgd_clf.predict([some_digit])array([ True])sgd_clf = SGDClassifier(random_state = 42)sgd_clf.fit(X_train, y_train_5)sgd_clf.predict([some_digit])from sklearn.model_selection import StratifiedKFoldfrom sklearn.base import clone # 使用交叉验证测量准确性skfolds = StratifiedKFold(n_splits = 3, random_state = 42)clone_clf = clone(sgd_clf)for train_index, test_index in skfolds.split(X_train, y_train_5): X_train_folds = X_train[train_index] y_train_folds = (y_train_5[train_index]) X_test_fold = X_train[test_index] y_test_fold = (y_train_5[test_index]) clone_clf.fit(X_train_folds, y_train_folds) y_pred = clone_clf.predict(X_test_fold) n_correct = sum(y_pred == y_test_fold) print(n_correct / len(y_pred)) from sklearn.model_selection import cross_val_scorecross_val_score(sgd_clf, X_train, y_train_5, cv = 3, scoring = "accuracy")from sklearn.base import BaseEstimator# 这个模型的预测的策略就是将所有的数据都认为是'非5'class Never5Classifier(BaseEstimator): def fit(self,X,y=None): pass def predict(self,X): return np.zeros((len(X),1), dtype=bool)never_5_clf = Never5Classifier()cross_val_score(never_5_clf, X_train, y_train_5, cv = 3, scoring = "accuracy")from sklearn.model_selection import cross_val_predict y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv = 3)]]></content>
      <tags>
        <tag>代码</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2021%2F02%2F14%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940/** * * @author devin * @date 2021-01-08 11:12 * @version 1.0.2*/public class SingleTest &#123; private static volatile SingleTest instance; private SingleTest()&#123; System.out.println("create method"); &#125; //在这里加同步太重 public static SingleTest getInstance()&#123; if(instance == null)&#123; synchronized (SingleTest.class)&#123; if(instance == null)&#123; return instance = new SingleTest(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; for(int i = 0;i &lt; 1000;i++)&#123; new Thread()&#123; @Override public void run() &#123; SingleTest.getInstance(); &#125; &#125;.start(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm参数调试demo]]></title>
    <url>%2F2021%2F02%2F13%2Fjvm%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95demo%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425/** * @author devin * @version 1.0.2 * @date 2021-01-13 20:48 */public class Demo2 &#123; private static final int _512KB = 512 * 1024; private static final int _1MB = 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(3); queue.add(2); queue.add(3); queue.add(5); queue.put(3); System.out.println(queue.take()); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wait 释放锁]]></title>
    <url>%2F2021%2F02%2F13%2Fwait-%E9%87%8A%E6%94%BE%E9%94%81%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class ThreadB2 extends Thread &#123; /** * 线程 BBB 持有对象锁 this，即当前对象 threadB2 */ @Override public void run() &#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + " beg " + System.currentTimeMillis()); System.out.println("B2 ing"); System.out.println(Thread.currentThread().getName() + " end " + System.currentTimeMillis()); &#125; &#125;&#125;class ThreadA2 extends Thread &#123; private ThreadB2 threadB2; public ThreadA2(ThreadB2 threadB2) &#123; this.threadB2 = threadB2; &#125; /** * 线程 AAA 持有对象锁 threadB2 */ @Override public void run() &#123; //B2 被锁住 synchronized (threadB2) &#123; System.out.println(Thread.currentThread().getName() + " beg " + System.currentTimeMillis()); try &#123; System.out.println("wait之前：" + threadB2.isAlive()); threadB2.wait(); System.out.println("wait之后：" + threadB2.isAlive()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;// try &#123;// Thread.sleep(2000);// &#125; catch (InterruptedException e) &#123;// &#125; System.out.println(Thread.currentThread().getName() + " end " + System.currentTimeMillis()); &#125; &#125;&#125;class Run2 &#123; public static void main(String[] args) &#123; ThreadB2 threadB2 = new ThreadB2(); threadB2.setName("B2"); ThreadA2 threadA2 = new ThreadA2(threadB2); threadA2.setName("A2"); threadA2.start(); threadB2.start(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象锁]]></title>
    <url>%2F2021%2F02%2F13%2F%E5%AF%B9%E8%B1%A1%E9%94%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[notify 的使用]]></title>
    <url>%2F2021%2F02%2F13%2Fnotify-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435public class NotifyTest &#123; public synchronized void testWait()&#123; System.out.println(Thread.currentThread().getName() +" Start-----"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +" End-------"); &#125; public static void main(String[] args) throws InterruptedException &#123; final NotifyTest test = new NotifyTest();// 创建五个线程取运行对象的方法 for(int i=0;i&lt;5;i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; test.testWait(); &#125; &#125;).start(); &#125; //通知一个 线程 synchronized (test) &#123; test.notify(); &#125; Thread.sleep(3000); System.out.println("-----------分割线-------------"); //通知所有线程 synchronized (test) &#123; test.notifyAll(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO通道的使用]]></title>
    <url>%2F2021%2F02%2F13%2FIO%E9%80%9A%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * * @author devin * @date 2021-01-07 15:52 * @version 1.0.2*/public class ChanTest &#123; private static FileOutputStream fileOutputStream; private static FileChannel fileChannel; public static &lt;buffer, buffer1, buffer2&gt; void main(String[] args) throws IOException, InterruptedException &#123; fileOutputStream = new FileOutputStream("D://out.txt"); fileChannel = fileOutputStream.getChannel(); for(int i = 0;i &lt; 10;i++)&#123; Thread thread1 = new Thread()&#123; @Override public void run() &#123; ByteBuffer buffer1 = ByteBuffer.wrap("123\r\n".getBytes()); try &#123; fileChannel.write(buffer1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread thread2 = new Thread()&#123; @Override public void run() &#123; ByteBuffer buffer2 = ByteBuffer.wrap("654\r\n".getBytes()); try &#123; fileChannel.write(buffer2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; Thread.sleep(3000); fileChannel.close(); fileOutputStream.close(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习一门知识]]></title>
    <url>%2F2021%2F02%2F13%2F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class BlockingQueueTest &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + "\t put A "); blockingQueue.put("A"); System.out.println(Thread.currentThread().getName() + "\t put B "); blockingQueue.put("B"); System.out.println(Thread.currentThread().getName() + "\t put C "); blockingQueue.put("C"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "t1").start(); new Thread(() -&gt; &#123; try &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; blockingQueue.take(); System.out.println(Thread.currentThread().getName() + "\t take A "); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; blockingQueue.take(); System.out.println(Thread.currentThread().getName() + "\t take B "); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; blockingQueue.take(); System.out.println(Thread.currentThread().getName() + "\t take C "); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "t2").start(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS 版本号应用]]></title>
    <url>%2F2021%2F02%2F13%2FCAS-%E7%89%88%E6%9C%AC%E5%8F%B7%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041/** * * @author devin * @date 2021-01-08 22:11 * @version 1.0.2*/public class MyUnsafe &#123; private static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;Integer&gt;(100,1); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println("t1拿到的初始版本号:" + atomicStampedReference.getStamp()); //睡眠1秒，是为了让t2线程也拿到同样的初始版本号 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; atomicStampedReference.compareAndSet(100, 101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); atomicStampedReference.compareAndSet(101, 100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); &#125;,"t1").start(); new Thread(() -&gt; &#123; //得到共享变量的版本号 int stamp = atomicStampedReference.getStamp(); System.out.println("t2拿到的初始版本号:" + stamp); //睡眠3秒，是为了让t1线程完成ABA操作 try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("最新版本号:" + atomicStampedReference.getStamp()); //确认当前值 修改值 确认版本号 赋值新的版本号 获得修改后的值 修改成功与否 System.out.println(atomicStampedReference.compareAndSet(100, 2019,3,atomicStampedReference.getStamp() + 1) + "\t当前 值:" + atomicStampedReference.getReference()); &#125;,"t2").start(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用]]></title>
    <url>%2F2021%2F02%2F13%2Fhexo%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[新建一篇文章 123hexo new "博客名称"hexo new page --path about/me "About me" 部署博客 1234# 编译hexo g# 发布博客hexo d 启动服务器 1hexo server 多分类 12345categories:- Diarytags:- PS3- Games 分类和标签的使用规范 12分类：优先级 以领域划分 机器学习 生活 web开发 标签：语言 读书笔记 代码]]></content>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 死锁代码]]></title>
    <url>%2F2020%2F12%2F30%2FJAVA%E6%AD%BB%E9%94%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243package jvm;/** * @author devin * @version 1.0.2 * @date 2021-01-17 14:17 */import java.util.concurrent.TimeUnit;/** * 资源类 */class HoldLockThread implements Runnable&#123; private String lockA; private String lockB; // 持有自己的锁，还想得到别人的锁 public HoldLockThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + "\t 自己持有" + lockA + "\t 尝试获取：" + lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + "\t 自己持有" + lockB + "\t 尝试获取：" + lockA); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6 模块的导入和导出]]></title>
    <url>%2F2020%2F10%2F30%2Fes6%20%20%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[b.js 12345678export function fun()&#123; console.log("fun1")&#125;export let person = &#123; name:"devin", age:12&#125; c.js 12345678let a = 12let fun = function()&#123; console.log("function")&#125;export default&#123; a,fun&#125; index.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="module" &gt; // import * as util from './a.js'; // //import &#123;fun, person&#125; from "./a.js"; // console.log(util.fun(),util.person) // import a from './exportDefault'; // a.show(); // console.log(a.a); // import * as util from "./b.js" import c from "./c.js" // console.log(util.fun) console.log(c.a) c.fun() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序原生组件的坑]]></title>
    <url>%2F2020%2F09%2F30%2Fmpvue%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[style 1&lt;scroll-view :style="&#123;'height': '300px'&#125;"&gt;&lt;/scroll-view&gt;要设置高度 原生的事件 12345678910111213141516&lt;scroll-view :style="&#123;'height': '300px'&#125;" :scroll-y="true" @scrolltolower="scrolltolower" @scroll="scroll" &gt; &lt;div :style="&#123;'height': '200px','background-color':'red'&#125;"&gt;tyuiolpo&lt;/div&gt; &lt;div class="" :style="&#123;'height': '200px','background-color':'red'&#125;"&gt;dsdsd &lt;/div&gt;&lt;div class="" :style="&#123;'height': '200px','background-color':'red'&#125;"&gt;grytyju&lt;/div&gt;&lt;/scroll-view&gt; 数据部分 methods: &#123; scrolltolower()&#123; console.log(7) &#125;, scroll(e) &#123; console.log(6) console.log(e) &#125;, &#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习一门知识]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[两种学习方法 1.1 了解知识的产生背景，了解知识的大致框架，慢慢往里面填空。 1.2 做测试，错了给自己电击反馈 学习的一些技巧 2.1 确定学习的输入输出 2.2 康奈尔笔记法，学习的内容自己用自己的话复述出来，最后做个整体总结。]]></content>
      <categories>
        <category>哲学与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas基本操作]]></title>
    <url>%2F2019%2F09%2F18%2Fpandas%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. pandas DataFrame对象的创建12dates = pd.date_range('20130101', periods=6)df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list('ABCD')) 2. 操作数据12345678910111213141516171819202122232425262728293031323334353637df.head()df.tail(3)df.indexdf.describe()# 单列索引df.iloc[1:2,2:]# 特定索引df.iloc[[1,2],[2,3]]# 布尔索引df[df&gt;0.5] = 1# 赋值列df2['E'] = ['A,','B','C','E','3','3']# 赋值行df2.loc['e'] = [1,2,3,4,5]#访问某个位置df2.iat[0,1]#删除带有缺失值的行df1.dropna(how = 'any')#填充空数据df1.fillna(value=5)# 获得每一列的平均值、df1.mean()# 获得每一行的平均值df1.mean(1)# 修改行标签df1.index = ['A','B','C']#修改行列data.rename(index=&#123;'A':'D', 'B':'E', 'C':'F'&#125;, columns=&#123;'a':'d','b':'e','c':'f'&#125;, inplace = True)#连接两个表pe = [df1,df2]pd.concat(pe)#数据库连接风格left = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'lval': [1, 2]&#125;)right = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'rval': [4, 5]&#125;)pd.merge(left, right, on='key')#写入文件df1.to_csv('foo.csv')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
