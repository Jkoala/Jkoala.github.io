<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cglib代理]]></title>
    <url>%2F2021%2F03%2F16%2FCglib%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435//被代理类public class PersonService &#123; public void eat()&#123; System.out.println("吃饭"); &#125;&#125;//代理类public class Cglib implements MethodInterceptor&#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class clazz)&#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("拿筷子" + method); Object invoke = methodProxy.invokeSuper(o, objects); System.out.println("洗碗" + method); return invoke; &#125;&#125;//mainpublic class Main &#123; public static void main(String[] args) &#123; Cglib ct = new Cglib(); PersonService proxy = (PersonService) ct.getProxy(PersonService.class); proxy.eat(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDK 动态代理]]></title>
    <url>%2F2021%2F03%2F16%2FJDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243//接口public interface Subject &#123; void doSomeThink();&#125;//实现类public class RealSubject implements Subject&#123; @Override public void doSomeThink() &#123; System.out.println("Do some thing"); &#125;&#125;//代理实现类/** * @author devin * @version 1.0.2 * @date 2021-03-16 15:49 */public class JDKProxy implements InvocationHandler &#123; private Object target; public JDKProxy(Object target) &#123; this.target = target; &#125; public &lt;T&gt; T getProxy()&#123; return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("do some thing before"); Object result = method.invoke(target,args); System.out.println("do some thing after"); return result; &#125;&#125;// main 类public class Main &#123; public static void main(String[] args) &#123; Subject subject = new JDKProxy(new RealSubject()).getProxy(); subject.doSomeThink(); &#125;&#125; 如何实现流程 为接口创建代理类的字节码文件 将字节码文件加载到JVM 创建代理类实例对象，执行目标的方法 proxy实现了哪些工作 代理类继承了Proxy类并且实现了要代理的接口，由于java不支持多继承，所以JDK动态代理不能代理类 重写了equals、hashCode、toString 有一个静态代码块，通过反射或者代理类的所有方法 通过invoke执行代理类中的目标方法doSomething ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java编程思想]]></title>
    <url>%2F2021%2F03%2F15%2Fjava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[第二章2.1 用引用来创建一个对象123//一切都是对象可以把引用作为一个遥控,例如 string a; //只是定义了遥控没有定义遥控的对象string a = "123" 才是OK 的 2.2 所有对象必须由你创建12345678string s = new String("1234");/*1. 寄存器访问最快的 位于CPU内部 但是数量有限 它是按需分配的 你不能感觉到它的存在2. 堆栈：位于通用RAM 仅次于寄存器 向下则分配内存 向上则释放内存 java系统需要知道堆栈中所有项的生命 周期3. 堆; 位于RAM 存储所有的java 对象 编译器不需要知道数据再堆中存活多长时间4. 常量存储： 可以存储再程序代码内部也可以存储再只读存储器中5. 非ram 存储： 两个基本的例子就是持久化和流对象*/ 基本数据类型 BigInteger BigDecimal 第五章1垃圾回收器准备垃圾回收之前先调用finalized 方法 并在下一次垃圾回收回收占用的内存 第八章1构造方法其实是静态方法 不过这种静态是隐性的]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常用算法总结]]></title>
    <url>%2F2021%2F03%2F13%2FC-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[PS:后续添加 没有顺序了 搜到什么看什么吧非char型数组的复制123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[] = &#123;1,2,3&#125;; int b[3]; memcpy(b,a,2*sizeof(int)); cout &lt;&lt; b[0] &lt;&lt; b[1] &lt;&lt; b[2] &lt;&lt; endl;&#125; 查找子串1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s1 = "123"; string s2 = "23"; string s3 = "73"; cout &lt;&lt; s1.find(s2) &lt;&lt; endl;; unsigned int c = s1.find(s3); cout &lt;&lt; c &lt;&lt; endl; // 如果没找到 发挥特别的指针 npos // freopen("in.txt","r",stdin);&#125; 数据初始化12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 220void display(int num)&#123; cout &lt;&lt; num &lt;&lt; " ";&#125;int main()&#123; int a[2][5],b[10]; //fill只能初始化一维数组 fill(b,b+10,1); //fill(a,a+100,1); memset(a,0,sizeof(a)); //for_each(a,a+MAXN,display); //数据输出 cout &lt;&lt; "b:" &lt;&lt; ":"; for_each(b,b+10,display); cout &lt;&lt; endl; // cout &lt;&lt; a &lt;&lt; ":"; // for_each(a,a+10,display); // cout &lt;&lt; endl;&#125; 最大公约数123456789//公倍数 两数相乘 除以公约数#include&lt;bits/stdc++.h&gt;using namespace std;int a[40] = &#123;1,2&#125;;int main()&#123; cout &lt;&lt; __gcd(12,6); //cout &lt;&lt; __INT32_MAX__ &lt;&lt; endl;&#125; 1.accumulate求和123456789101112#include&lt;numeric&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(3); v.push_back(5); v.push_back(9); cout &lt;&lt; accumulate(v.begin(),v.end(),0); //0是累加的初值&#125; 2. atof 字符串转换为double12345678910111213/* 字符串 类型换成double类型 */#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;stdlib.h&gt;using namespace std;int main()&#123; char a[] = "123" ; int b = atof(a); cout &lt;&lt; b;&#125; 3. 容器为空 begin和end相等123456789101112#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; if(v.begin()==v.end()) cout &lt;&lt; "ok1" &lt;&lt; endl; v.push_back(4); if(v.begin()==v.end()) cout &lt;&lt; "ok2" &lt;&lt; endl;&#125; 4. bitset 可实现十进制和二进制的互换 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; bitset&lt;32&gt; a(8); cout &lt;&lt; a[1] &lt;&lt; endl; int b; b = a.to_ullong(); cout &lt;&lt;a &lt;&lt; " " &lt;&lt; b &lt;&lt;endl;&#125;​```c### 5.copy ​```c/* copy(begin,end,begin) 将第一个数组的begin至end 赋值到第二个容器begin开始 */#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;template &lt;class T&gt;void print(T x)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125; int main()&#123; int a[] = &#123;1,2,3,4,5,6,7,8,9&#125; ; int b[] = &#123;9,8,7,6,5,4,3,2,1&#125; ; // copy(a,a+5,b); //复制前五个 for_each(b,b+9,print&lt;int&gt;);&#125; 6. count1234567891011121314151617181920/* count(begin,end, int) 大于int型的数 count_if(begin,end,fun) 自定义函数 */#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;template &lt;class T&gt;void print(T x)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125; int main()&#123; int a[10] = &#123;1,2,3,4,5,5,7,8,9,10&#125;; cout &lt;&lt; count(a,a+10,10); //for_each(a,a+9,print&lt;int&gt;) ;&#125; 7. erase()12345678910111213141516#include&lt;iostream&gt;using namespace std;void fun(string &amp;str)&#123; str.pop_back();&#125;int main()&#123; string s= "123456"; cout &lt;&lt; s &lt;&lt; endl; fun(s); cout &lt;&lt; s &lt;&lt; endl; //删除某一段的数值 s.erase(s.end()-2,s.end()-1); cout &lt;&lt; s &lt;&lt; endl;&#125; 8. find_if()123456789101112131415161718192021222324252627282930/* find_if(begin,end,greatThree) 找到大于三的所以所有数，return 首地址 就是一个数组*/#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;bool greatThree(int x)&#123; if(x &gt; 3) return true; else return false;&#125;template &lt;class T&gt;void print(T x)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125; int main()&#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int *p = find_if(a,a+10,greatThree) ; for(int i = 0;i &lt; 7;i++) cout &lt;&lt; *p++ &lt;&lt;endl; //for_each(a,a+9,print&lt;int&gt;) ;&#125; 9 find123456789101112131415161718/* find返回找到元素的地址 */#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;template &lt;class T&gt;void print(T x)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125; int main()&#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; cout &lt;&lt; find(a,a+10,6); &#125; 10.for_each()1234567891011121314#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;template &lt;class T&gt;void print(T x)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125; int main()&#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; for_each(a,a+10,print&lt;int&gt;);&#125; 11.itoa int类型换成char类型 还可以设置转换进制十进制可以转换成任意进制 12345678910111213/* int 类型换成string类型 */#include&lt;iostream&gt; #include&lt;stdlib.h&gt; using namespace std;int main()&#123; int a = 64; char b[3]; itoa(a,b,8); //8表示转换后的进制 cout &lt;&lt; b[0] &lt;&lt; b[1] &lt;&lt; b[2];&#125; 12. max_element 和 min_element 求最大最小元素123456789101112/* *max_element(begin,end) 求最大成员 */#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;int main()&#123; int a[] = &#123;1,2,5,6,3,4,8,9,7&#125; ; cout &lt;&lt; *max_element(a,a+9);&#125; 13. memset 初始化 可以如下替代 12345678#include&lt;iostream&gt;using namespace std;int main()&#123; int a[10],b[10] = &#123;1,2,3&#125;; for(int i = 0;i &lt; 10;i++) cout &lt;&lt; a[i] &lt;&lt; " " &lt;&lt; b[i] &lt;&lt; endl;&#125; memset 123456789101112/* 初始化数组 */#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std;int main()&#123; int a[10] ; memset(a,0,10); //十个全部放0 &#125; 14.replace_if() 满足条件的替换123456789101112131415161718192021222324252627/* replace_if(begin,end,fun,int)将满足fun条件的换成int replace(begin,end,3,5) 将所以的3替换成5 */#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;bool greatTree(int x) &#123; if(x &gt; 3) return true; else return false;&#125;template &lt;class T&gt;void print(T x)&#123; cout &lt;&lt; x &lt;&lt; endl;&#125; int main()&#123; int a[] = &#123;1,2,3,4,5,6,7,8,9&#125; ; replace_if(a,a+9,greatTree,9);//大于三的数替换成9 for_each(a,a+9,print&lt;int&gt;) ;&#125; 15.strstr() char*类型找到子串12345678910111213#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int main()&#123; char* str = "I am a Android developer!"; char* subStr = "Android"; char* result = strstr(str, subStr); //找到子串后面的字符串 printf("result = %s\n", result);//结果：result = Android developer! return 0;&#125; 16. substr() 截取字符123456789#include&lt;iostream&gt;using namespace std;int main()&#123; string str = "123456789"; //__LONG_LONG_MAX__ a = 18374001125; cout &lt;&lt; str.substr(2,3); //截取第i个字符后面三个&#125; 17.计时 getTIckCount()1234567891011121314#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;int main()&#123; long n = 1000000000; long t1 = GetTickCount(); //...娴嬭瘯浠ｇ爜 while(n--); long t2 = GetTickCount(); cout &lt;&lt; "time:"&lt;&lt;(int(t2)-int(t1)) &lt;&lt; endl; return 0;&#125; 18.toupper() 和 tolower 字符的变换123456789#include&lt;iostream&gt;using namespace std;int main()&#123; string a = "oIu"; a[0] = toupper(a[0]); a[0] = tolower(a[1]); cout &lt;&lt; a;&#125; 19. 去重复unique() 必须已经排序12345678910111213141516#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void print(int a)&#123; cout &lt;&lt;a &lt;&lt; " ";&#125;int main()&#123; int a[6] =&#123;1,1,2,2,3,3&#125;; for_each(a,a+6,print); cout &lt;&lt; endl; int pos = unique(a,a+6)-a; for_each(a,a+6,print); cout &lt;&lt; endl;&#125; 20. 判断isalpha()1234567891011121314151617/* 判断字符或数字 */#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;int main()&#123; char a = 'r' ,b = '1'; if(isalpha(a)) cout &lt;&lt; "ok" ; if(isdigit(b)) cout &lt;&lt; "ko"; &#125; 21. 取第k位数字123456789101112131415161718#include&lt;stdio.h&gt; int len(int x)&#123; if(x&lt;10) return 1; return len(x/10)+1;&#125;// 取x的第k位数字int f(int x, int k)&#123; if(len(x)-k==0) return x%10; return f(x/10,3); //填空&#125;int main()&#123; int x = 23574; printf("%d\n", f(x,3)); return 0;&#125; 交并集123456789101112131415161718192021#include&lt;sstream&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;void print(int n)&#123; cout &lt;&lt; n &lt;&lt; " ";&#125;int main()&#123; vector&lt;int&gt; v1 = &#123;1,2,3&#125;,v2=&#123;2,3,4&#125;,v3; //差集 // set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), inserter(v3, v3.begin())); // 交集 // set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), inserter(v3, v3.begin())); //并集 set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), inserter(v3, v3.begin())); v1 = v3; for_each(v1.begin(),v1.end(),print);&#125; vector 通过值删除1234567891011121314#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void print(int n)&#123; cout &lt;&lt; n &lt;&lt; " ";&#125;int main()&#123; vector&lt;int&gt; v=&#123;1,2,3,4,5&#125;; v.erase(remove(v.begin(),v.end(),3)); for_each(v.begin(),v.end(),print);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybaties]]></title>
    <url>%2F2021%2F02%2F28%2Fmybaties%2F</url>
    <content type="text"><![CDATA[myabties 执行器SIMPLE 方式从执行日志可以看出, 每次插入操作, 都会执行编译, 设置参数, 执行sql操作. REUSE 方式从执行日志可以看出, 只有第一次插入操作, 执行了sql编译步骤, 对其它插入操作执行了设置参数, 执行sql的操作. 批量从执行日志可以看出, 只对第一次插入操作执行了sql编译操作, 对其它插入操作仅执行了设置参数操作, 最后统一执行. 常见问题答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2021%2F02%2F28%2FJVM%2F</url>
    <content type="text"><![CDATA[JVM 内存模型 线程共享 堆和方法区 线程私有 虚拟机栈 本地方法栈 程序计数器 方法区： 原来是通过永久代来实现，现在通过元空间实现，永久代是堆的一部分，元空间属于本地内存。元空间主要存储元信息，静态变量和常量池并入堆中。 静态变量 静态代码块 静态方法 构造代码块 堆 对象的非静态成员变量 栈内存 存储局部变量 类加载机制​ 七个阶段： 加载 验证 准备 解析 初始化 使用 卸载 加载 - 通过一个类的权限域名获取他的二进制字节流 - 将二进制字节流代表的静态存储结构转化为方法区运行的数据结构 - 将java 堆生成代表这个类的class 对象作为读取方法区数据的访问入口 - Xmx 最大堆内存 Xms 初始堆内存四大引用强引用我们平常new 这个对象 软引用：内存空间够就不会回收大 弱引用，不管空间是否够都能引用他。 虚引用主要用来跟踪垃圾回收的过程。 什么可以作为GCRPOOT 的引用对象java 虚拟机栈中的引用对象 方法区中类静态属性引用对象 方法区产常量引用对象 本地方法栈中的引用对象 GC 回收的过程 1、发生Young GC之前进行检查，如果“老年代可用的连续内存空间” &lt; “新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间，此时会触发FullGC 2、当老年代没有足够空间存放对象时，会触发一次FullGC 3、如果元空间区域的内存达到了所设定的阈值-XX:MetaspaceSize=，也会触发FullGC。 String Stringbuffer 是线程安全的 StringBuilder线程不安全]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2021%2F02%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[http 报文的结构 ：请求行、请求头部、空行和请求数据4个部分组成 端口 80 明文传输 HTTP1.0 和 1.1 的区别 持久链接 还提供身份认证 HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。 TCP 如何保证有效连接（运输层） 确认和重传 数据效验 流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。 拥塞控制：当网络拥塞时，减少数据的发送。 滑动窗口 三个窗口 ： 发送窗口 接受窗口 拥塞窗口 输入URL 后面发生的事情 查找 地址浏览器的缓存记录 如果就需要找域名服务器 迭代查询 递归查询过 找到Ip 建立链接 http发起请求 服务器响应 渲染页面 构建dom 树 Ip和mac 地址 Ip 地址确定 主机的拓扑位置 物理地址区分不同主机的编号 mac是一个身份标识 IP 是动态变化的 类比家庭住址和身份证 慢开始 拥塞避免 快重传 连接建立好后，初始拥塞窗口的大小为1 表明可以传一个MSS 大小的数据 在到达门限阈值之后每收到一个ACK窗口值就翻倍 到了门限阈值后收到ACK就一步一步增加1， 收到三个重复ACK 就将门限阈值提到变为当前的一半，再执行加法增大 TCP UDP 传输层 TCP是可靠的 ​ TCP 通过拥塞控制 确认机制来保证可靠性 UDP 不保证可靠性 HTTP HTTPS HTTPS 其实就是加密的HTTP]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring]]></title>
    <url>%2F2021%2F02%2F28%2Fspring%2F</url>
    <content type="text"><![CDATA[切面编程，AOP 的实现关键在于代理 代理分为静态代理和动态代理。 静态代理时AspectJ 动态代理有CGlib 和 jdk JDK动态代理只提供接口的代理，不支持类的代理 CGlib是一个代码生成类库 通过继承方式实复写特定方法实现代理。 常用注解1. 注册bean 对象 @Component kəmˈpoʊnənt @Controller @Service @Repository @bean 2. 自动装配 @Autowired waɪərd Qualifier kwɑːlɪfaɪər @Resource @Value 3. bean 的范围 @Scope 4. 生命周期相关 @PostConstruct @PreDestroy 前端控制器前端控制器 去找处理映射器 得到一个执行链 前端控制器再去调用处理适配器 找到对应的controller 返回modelandview 在去调用视图解析器 返回view 主要是填充页面的参数 渲染完成后返回给view 试图 bean 的作用范围单例 prototype request session global-session ###]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JUC]]></title>
    <url>%2F2021%2F02%2F28%2Fjuc%2F</url>
    <content type="text"><![CDATA[synchronized synchronized 的修饰对象 静态方法 获得本类对象 方法 本实例对象 代码块： 可以指定锁对象 原理 当程序执行到synchronized 修饰段的时候，线程会尝试获取它的监视器对象 如果监视器进入数为0 则该线程获得监视器，然后设置进入树为1 可重入 如果monitor 对象已经被其他线程获取，则该线程进入阻塞状态，直到monitor 进入数为0 wait notify wait 和 notify 就是一个暂停运行 一个通知运行，当时必须获得锁以后才可以执行该对象，而且获得的锁必须是相同的锁机制。 锁的原理也是获得监控器的对象， wait 立刻释放锁 notify 一次只唤醒一个线程且唤醒的顺序和执行wait方法的顺序一致 volatile 关键字 保证可见性 不保证原子性 禁止指令重排 守护进程和用户进程用户进程就是用户创建的进程 不需要上乘逻辑介入 主线程结束 自动结束 普通线程是一直run 完 可能 阻塞队列 普通阻塞队列 数组阻塞队列 一旦指定了队列的长度，则队列的大小不能改变 先进先出 数组实现 列表阻塞队列 先进先出 可以设置有限也可以设置无限 优先阻塞队列 插入的对象必须可以比较的 异步阻塞队列 put 必须等待take take也必须等待put lock 和 synchronized 的区别 lock 是一个类 发送异常不会释放锁 synchoronized 不会释放锁 线程池 线程池的配置 CPU 密集性 +1 IO密集型 CPU/(1-阻塞系数) 线程池的参数 核心线程数 最大线程数 存活时间 存活时间单位 任务队列 线程工厂 拒绝策略 拒绝策略比如不管什么情况直接抛出异常 或者任何处理继续运行 线程池的创建 1.newCachedThreadPool创建一个可缓存线程池程 2.newFixedThreadPool 创建一个定长线程池 3.newScheduledThreadPool 创建一个定长线程池 4.newSingleThreadExecutor 创建一个单线程化的线程池 锁机制公平锁就是按申请顺序执行 非公平锁就是部分优先级高的可以加塞 可重入锁就是进入锁内部仍然可以获得该锁 不停地空耗CPU 中心锁默认是非公平的 乐观锁默认操作不会修改数据 使用CAS 悲观锁默认会修改数据 使用Synchronized 在对记录进行修改前，先尝试为该记录加上排他锁(exclusive locks)。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 期间如果有其他对该记录做修改或加排他锁的操作，都会等待解锁或直接抛出异常。 死锁死锁预防是添加某种限制条件 比如设定某线程必须在另一个线程全部执行完之后才能执行 sleep yeild①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 AQS 抽象对垒同步器]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集合框架]]></title>
    <url>%2F2021%2F02%2F28%2Fjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Hashmap 的特性 hashmap特性 hashmap 可以实现快速存取 key 允许为null 非同步 线程不安全 底层时hash表 hashmap 的底层实现原理 底层时数组加链表 put get存取对象 当执行put 方法时 , 先对键值计算hashcode()得到它在bucket数组的位置。获取对象时，先得到bucket的位置 在调用equals 找到需要的值。 put 方法的流程 计算机hashcode 判断hash表是否为空 发生碰撞放到散列表里去 hashcode 值相同 三种情况 equals 判断是否有相同 红黑树就调用红黑树的插入方法 链表就在尾部插入 如果插入链表个数为8 就转变为红黑树 如果满了就扩容。 hashmap 什么时候需要扩容 通过判断数组容量是否大于0 判断数组是否初始化过 没有初始化 是否初始化默认大小 是否初始化容量 扩容两倍将元素重新运算复制到新的散列表中 5.谈一下hashMap中get是如何实现的？ 对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。 hashmap 和 hashtable 的区别 相同点 都是key-value 存储 HashMap允许Key-value为null，hashTable不允许； hashMap没有考虑同步，是线程不安全的。hashTable是线程安全的，给api套上了一层synchronized修饰; hashmap 的初始容量是16 hashtable 的初始容量是 11 (2*n+1) hashmap 自定义的hash算法 hashtable 没有自定义hash算法 treemap 一般按照key 排序 String StringBuffer StringBuilder Stringbuffer 是线程安全的 StringBuilder线程不安全]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2021%2F02%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[mysql 数据库事务四大特性 原子性 隔离性 一致性 持久性 数据库的索引 脏读：事务B查看事务A 每天提交的数据 不可重复读：一行被检索两次，并且该行，在不同的读取之时不同 其他会话修改数据 读未提交 不可重复读 可重复读（默认） 串行化 存储引擎： 都是采用表级别锁 MYISAM: （非聚集索引） 不支持外键 不提供事务 插入数据时 锁定整个表所以每次查询具有原子性 可以直接读取行数变量 INNODB: （聚集索引） 支持事务和行级别锁 聚集索引 读取行数需要执行查询语句 MYSQl 5.5 之后默认是INNODB 考虑存储引擎的几点 是否支持事务 是否读写频繁 系统崩溃后 MyISAM恢复起来更困难 数据库三大范式 属性不可分 比如姓名 姓和名 非主键属性完全依赖于主键属性： 比如学生id和姓名 非主键属性是通过课程 ID 连接起来你不能通过ID 把他们弄在一起 数据库的锁 按照颗粒度来分的话 行级别锁： 开销大，加锁慢，会出现死锁。发生锁冲突的概率最低，并发度也最高。 顾名思义就是对行进行加锁 他的颗粒粒度是最小的 还有间隙锁 和 表级别锁： 开销小，加锁快，不会出现死锁。发生锁冲突的概率最高，并发度也最低。 有两种锁 读锁锁表 写锁锁表 MYISAM 默认是加表锁的 INNODB 要加表说就需要显式的声明了 页级锁 是表锁和行锁中间隔离级别的一种锁 按共享策略来分可以分为 共享锁 读锁 排他锁 写锁 意向共享锁 意向排他锁的作用主要是快速判断一个表是否被上锁 从加锁策略来分的 话可以分为 乐观锁 默认对数据的操作是查询比较多 增删比较少 悲观锁 默认修改多查询少 不加锁一定出问题 其他还有一个自增锁 主要用于自增片段 mysql 索引 索引算法 hash 算法实现 不能进行 范围查询 不能排序 B+ 索引 聚集索引非聚集索引 聚集索引 按索引的顺序存储 节点中存储正在的物理数据 非聚集索引:存储指针 查询非指针数据时需要查询两次、 为什么使用索引 索引最大的好处是提高查询速度，缺点是更新数据时效率低，因为要同时更新索引对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。 为什么用B+ 树 他和B树的区别 B 所有节点都存储key和data 所有节点组成这颗树 叶子节点为空 B+ 只有叶子节点存储data 叶子节点包含了这棵树所有的键值 叶子节点不存储指针 数据库的主从复制 为什么需要主从复制 主从复制就是做一个备份的数据库，主数据库崩塌后可以立马切换到从数据库，避免数据丢失 主从复制的原理 sql 优化1234子查询变成left joinwhere代替having,having 检索完所有记录，才进行过滤避免嵌套查询对多个字段进行等值查询时，联合索引 123// 通过ID 来过滤select * from table limit 100000,20select * from table where id &gt; (select id from table limit 100000,1) limit 100000,20 索引失效的场景- 未使用该列作为查询条件 - 使用like通配符在前面 - 查询使用ORredis 缓存雪崩 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 解决方案：将缓存失效的时间分隔开 缓存击穿 缓存失效的时候大量请求发送过来 解决方案：用互斥锁 先判断是否失效 ​ 失效就先重新设置缓存 在查询 缓存穿透 访问一个不存在的数据 解决方案：先做一个预判断]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2021%2F02%2F27%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[进程和线程​ 进程的各个状态 就绪等待被调度 运行 正在执行中 阻塞；缺少需要的资源 等待中 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 线程的各个状态之间的切换 就绪 ：进程处于准备好的状态 得到CPU 就可以运行 执行：进程获得cpu 执行 阻塞：正在执行的进程由于发生某事件 暂时无法继续执行 进程和线程 进程： 进程是系统进行资源分配和调度的一个独立单位 线程：是CPU分配和调度的基本单位 进程和线程的关系 一个进程可以拥有多个线程 进程和线程的区别 进程有自己的独立地址空间 线程没有 进程是资源分配的最小单位线程是CPU分配的最小单位 线程通信更方便： 比如同一进程下线程共享数据（全局变量 静态变量） 进程切换代价高 进程切换 需要切换目录地址空间 切换内核栈 硬件上下文 进程调度 非抢占式调度 抢占式调度 调度算法 先进先出，最短作业优先 优先权调度算法 轮转调度算法 多级队列调度 一个程序从开始到结束的过程 预处理 ：头文件包含 宏替换 编译：将预处理的文件转换成汇编语言 汇编：将汇编代码转成二进制文件 链接：链接目标生成可执行文件 程序和进程​ 程序是永久的，进程是暂时的，程序是在数据集上的一次执行 ​ 程序是静态的观念，进程是动态的观念 ​ 进程具有并发性，而程序没有 ​ 进程和程序不是一一对应的，一个程序可以拥有多个进程。 ​ 程序有一定的生命周期 了解哪些寄存器通用寄存器 标志寄存器 段寄存器 进程通信的方式1. 管道通信 ： 命名管道：在内核申请一块固定大小的缓冲区 。程序拥有读写的权利 匿名管道： 2. 消息队列： 在内核中创建一个队列，队列存储的元素是一个个数据报，不同进程通过句柄去访问这个队列 3. 信号量： 主要是PV操作 4. 共享内存： 主要是将一块物理地址映射到不同的进程虚拟地址空间中，实现不同进程堆同一志愿的共享 5. 套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 比如QQ 聊天 死锁的四个条件​ 互斥 不可剥夺 循环等待 请求和保持 ​ 当系统出于安全状态时一定不会进入死锁 ​ 当系统处于不安全状态时不一定会死锁 进程调度算法：​ 先来先服务 ​ 短作业优先 ​ 时间片轮转调度 高响应比优先 优先权调度算法 多级队列调度算法 内存管理的方式：段页式存储 ​ ① 随机算法：用软件或硬件随机数产生器确定替换的页面 ② 先进先出：先调入主存的页面先替换 ③ 近期最少使用算法（LRU，Least Recently Used）：替换最长时间不用的页面 ④ 最优算法：替换最长时间以后才使用的页面。这是理想化的算法，只能作为衡量其他各种算法优劣的标准。 IO 控制的方式：​ 有轮询 中断 DMA 外中断和异常有什么区别？外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 磁盘调度算法​ 先来先服务 ​ 最短寻道优先 ​ 电梯算法 动态分区分配算法有哪几种？可以分别说说吗？1、首次适应算法算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。 如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。 2、最佳适应算法算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。 如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 3、最坏适应算法又称最大适应算法(Largest Fit) 算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 4、邻近适应算法算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。 如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 ​ 程序的编译过程 预编译 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下 1231. 处理所有的预处理命令2. 处理 define 命令 将内容替换到对应的位置3. 删除注释 添加行号和文件标识 （）便于调试信息时能够显示行号 编译 进行语法语义分析生成 汇编代码 .i 文件 汇编： 将汇编代码转化成机器码 链接：将不同目标文件链接转化成一个可执行文件 操作系统在对内存进行管理的时候需要做些什么? 操作系统负责内存空间的分配与回收。 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰 五大IO 模型 阻塞Io 非阻塞IO 不断询问 询问中间 可以做其他的事情 信号驱动： 用户事先在内核注册一个信号处理函数，管道和内核进行交互，当管道中的某个请求需要的数据处理好之后，进程再把对应的数据拷贝到用户空间中。 IO 复用模型 NIO Channel , Selector，Buffer 多个进程的IO 可以注册到同一个管道上，这个管道会统一和内核进行交互，当管道中数据准备好之后，进程再把对应的数据拷贝到用户空间。 异步IO 应用进程 把IO请求传递给内核后，完全由内核去操作文件拷贝，内核完成相关操作后，会发信号告诉本次应用进程本次IO 已经完成。 ​ ​]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker 常用命令]]></title>
    <url>%2F2021%2F02%2F27%2Fdocker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819• 容器有三种状态 暂停 运行 停止• docker exec -it eb14fc75272f bash• docker exec -i re bash -c &quot;ls als&quot;• -t 表示进入容器内执行命令• docker rm e00b8e3e3e2e 移除镜像• docker run --name helloworld hello-world• 移除镜像 docker rmi hello-world• 已打包的镜像 交父镜像 父镜像移除子镜像必须先移除父镜像• docker 打包项目镜像• 导入JDK 环境• 新疆Dockerfile 文件 • From ubuntu:20.04• COPY jdk1.8.0_271 /test• COPY helloworld.jar /test• docker build -t demo:1.0 .• docker cp 拷贝镜像到宿主机 反过来可以• docker cp helloworld.jar demo:/test• h]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hashmap详解]]></title>
    <url>%2F2021%2F02%2F25%2Fhashmap%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[hashmap特性 hashmap 可以实现快速存取 key 允许为null 非同步 线程不安全 底层时hash表 负载因子是0.75 hashmap 的底层实现原理 底层时数组加链表 put get存取对象 当执行put 方法时 , 先对键值计算hashcode()得到它在bucket数组的位置。获取对象时，先得到bucket的位置 在调用equals 找到需要的值。 put 方法的流程 计算机hashcode 判断hash表是否为空 发生碰撞放到散列表里去 hashcode 值相同 三种情况 equals 判断是否有相同 相同就替换 红黑树就调用红黑树的插入方法 链表就在尾部插入 如果插入链表个数为8 就转变为红黑树 如果满了就扩容。 hashmap 什么时候需要扩容 通过判断数组容量是否大于0 判断数组是否初始化过 没有初始化 是否初始化默认大小 是否初始化容量 扩容两倍将元素重新运算复制到新的散列表中 5.谈一下hashMap中get是如何实现的？ 对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。 hashmap 和 hashtable 的区别 相同点 都是key-value 存储 HashMap允许Key-value为null，hashTable不允许； hashMap没有考虑同步，是线程不安全的。hashTable是线程安全的，给api套上了一层synchronized修饰; hashmap 的初始容量是16 hashtable 的初始容量是 11 (2*n+1) hashmap 自定义的hash算法 hashtable 没有自定义hash算法 loadfactor 表示hash 表的拥挤程度 ​]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2021%2F02%2F25%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public interface IGamePlayer &#123; public void killBoss(); public void upGrade();&#125;public class GamePlayer implements IGamePlayer&#123; private String name; public GamePlayer() &#123; &#125; public GamePlayer(String name) &#123; this.name = name; &#125; @Override public void killBoss() &#123; System.out.println("打怪"); &#125; @Override public void upGrade() &#123; System.out.println("升级"); &#125;&#125;public class GamePlayerProxy implements IGamePlayer&#123; private IGamePlayer player = null; public GamePlayerProxy(IGamePlayer player)&#123; this.player= player; &#125; private void log()&#123; System.out.println("打怪 时间 " + new Date().toString()); &#125; @Override public void killBoss() &#123; System.out.println("打怪前"); player.killBoss(); System.out.println("打怪后"); &#125; @Override public void upGrade() &#123; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; GamePlayer gamePlayer = new GamePlayer("李逍遥"); GamePlayerProxy gamePlayerProxy = new GamePlayerProxy(gamePlayer); gamePlayerProxy.killBoss(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2021%2F02%2F25%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class Article &#123; public abstract void produce();&#125;public abstract class Video &#123; public abstract void produce();&#125;//实现类public class JavaArticle extends Article&#123; @Override public void produce() &#123; System.out.println("生产文章"); &#125;&#125;public class JavaVideo extends Video&#123; @Override public void produce() &#123; System.out.println("生成video"); &#125;&#125;课程public interface CourseFactory &#123; Video getVideo(); Article getArtcle();&#125;public class MyFactory implements CourseFactory&#123; @Override public Video getVideo() &#123; return new JavaVideo(); &#125; @Override public Article getArtcle() &#123; return new JavaArticle(); &#125;&#125;//主类public class Client &#123; public static void main(String[] args) &#123; MyFactory myFactory = new MyFactory(); Article artcle = myFactory.getArtcle(); Video video = myFactory.getVideo(); artcle.produce(); video.produce(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[招银云创二面凉经]]></title>
    <url>%2F2021%2F02%2F24%2F%E6%8B%9B%E9%93%B6%E4%BA%91%E5%88%9B%E4%BA%8C%E9%9D%A2%E5%87%89%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[自我介绍 巴拉巴拉 介绍提到大学开发过项目 针对项目 问的问题 问我用过那些注解 谈谈@Controller 和@Service 的区别 controller service dao 分别写什么代码 原来用ssm 现在 为什么用springboot springboot 为什么可以简化配置 Mybaties 执行器 Mybaties 用过那些标签 mybaties 可以重载？ JUC 谈谈JUC 的理解 synchronized 如何实现同步 集合框架 谈谈你对hashmap 的理解 hashmap 和hashtable 的区别 hashmap 为什么是线程安全额 hash map 的key和value 可以为空 为什么不能为空 总结面试时间是半小时 面试的是公司的架构师，问题都很开放先谈理解 根据你说的再问。]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2021%2F02%2F23%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[z责任链模式: 新建请求 新建各级主管 新建各级主管建立链表 初级主管开始 判断能否处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class AbstractLeaveHandler &#123; /**直接主管审批处理的请假天数*/ protected int MIN = 1; /**部门经理处理的请假天数*/ protected int MIDDLE = 3; /**总经理处理的请假天数*/ protected int MAX = 30; /**领导名称*/ protected String handlerName; /**下一个处理节点（即更高级别的领导）*/ protected AbstractLeaveHandler nextHandler; /**设置下一节点*/ protected void setNextHandler(AbstractLeaveHandler handler)&#123; this.nextHandler = handler; &#125; /**处理请假的请求，子类实现*/ protected void handlerRequest(LeaveRequest request)&#123; &#125;&#125;//直接主管public class DirectLeaderLeaveHandler extends AbstractLeaveHandler&#123; public DirectLeaderLeaveHandler(String name) &#123; this.handlerName = name; &#125; @Override protected void handlerRequest(LeaveRequest request) &#123; if(request.getLeaveDays() &lt;= this.MIN)&#123; System.out.println("直接主管:" + handlerName + ",已经处理;流程结束。"); return; &#125; if(null != this.nextHandler)&#123; this.nextHandler.handlerRequest(request); &#125;else&#123; System.out.println("审批拒绝！"); &#125; &#125;&#125;//部门经理public class DeptManagerLeaveHandler extends AbstractLeaveHandler&#123; public DeptManagerLeaveHandler(String name) &#123; this.handlerName = name; &#125; @Override protected void handlerRequest(LeaveRequest request) &#123; if(request.getLeaveDays() &gt;this.MIN &amp;&amp; request.getLeaveDays() &lt;= this.MIDDLE)&#123; System.out.println("部门经理:" + handlerName + ",已经处理;流程结束。"); return; &#125; if(null != this.nextHandler)&#123; this.nextHandler.handlerRequest(request); &#125;else&#123; System.out.println("审批拒绝！"); &#125; &#125;&#125;//总经理public class GManagerLeaveHandler extends AbstractLeaveHandler&#123; public GManagerLeaveHandler(String name) &#123; this.handlerName = name; &#125; @Override protected void handlerRequest(LeaveRequest request) &#123; if(request.getLeaveDays() &gt; this.MIDDLE &amp;&amp; request.getLeaveDays() &lt;= this.MAX)&#123; System.out.println("总经理:" + handlerName + ",已经处理;流程结束。"); return; &#125; if(null != this.nextHandler)&#123; this.nextHandler.handlerRequest(request); &#125;else&#123; System.out.println("审批拒绝！"); &#125; &#125;&#125;//请求public class LeaveRequest &#123; //请求天数和名字 private int leaveDays; private String name;&#125;//客户端public class ResponsibilityTest &#123; public static void main(String[] args) &#123; LeaveRequest request = LeaveRequest.builder().leaveDays(5).name("小明").build(); AbstractLeaveHandler directLeaderLeaveHandler = new DirectLeaderLeaveHandler("县令"); DeptManagerLeaveHandler deptManagerLeaveHandler = new DeptManagerLeaveHandler("知府"); GManagerLeaveHandler gManagerLeaveHandler = new GManagerLeaveHandler("京兆尹"); directLeaderLeaveHandler.setNextHandler(deptManagerLeaveHandler); deptManagerLeaveHandler.setNextHandler(gManagerLeaveHandler); directLeaderLeaveHandler.handlerRequest(request); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2021%2F02%2F23%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//策略类public abstract class Strategy &#123; public abstract void algorithmInterface();&#125;//策略A 和 策略Bpublic class StrategyA extends Strategy&#123; @Override public void algorithmInterface() &#123; System.out.println("算法A 的思想"); &#125;&#125;// 策略Bpublic class StrategyB extends Strategy&#123; @Override public void algorithmInterface() &#123; System.out.println("算法B 的思想"); &#125;&#125;// 策略的执行对象public class Context &#123; Strategy strategy; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public void contextInterFace()&#123; strategy.algorithmInterface(); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Context context; context = new Context(new StrategyA()); context.contextInterFace(); context = new Context(new StrategyB()); context.contextInterFace(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS实现锁的框架]]></title>
    <url>%2F2021%2F02%2F17%2F%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[s]]></content>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch 和 CyclicBarrier]]></title>
    <url>%2F2021%2F02%2F17%2FCountDownLatch%20%E5%92%8C%20CyclicBarrier%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637public class CountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(4); for(int i = 0;i &lt; latch.getCount();i++)&#123; new Thread(new MyThread(latch),"player" + i).start(); &#125; System.out.println("等待 所所有玩家 准备好"); latch.await(); System.out.println("开始游戏"); &#125; private static class MyThread implements Runnable&#123; private CountDownLatch latch; public MyThread(CountDownLatch latch)&#123; this.latch = latch; &#125; @SneakyThrows @Override public void run() &#123; Random rand = null; try &#123; rand = new Random(); int randomNum = rand.nextInt((3000 - 1000) +1 ) + 1000; Thread.sleep(randomNum); System.out.println(Thread.currentThread().getName() + "已经准备好 " + "所使用的时间是：" + randomNum ); latch.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; CyclicBarrier barrier = new CyclicBarrier(3); for(int i = 0; i &lt; barrier.getParties(); i++)&#123; new Thread(new MyRunnable(barrier), "队友"+i).start(); &#125; System.out.println("main function is finished."); &#125; private static class MyRunnable implements Runnable&#123; private CyclicBarrier barrier; public MyRunnable(CyclicBarrier barrier)&#123; this.barrier = barrier; &#125; @Override public void run() &#123; for(int i = 0; i &lt; 3; i++) &#123; try &#123; Random rand = new Random(); int randomNum = rand.nextInt((3000 - 1000) + 1) + 1000;//产生1000到3000之间的随机整数 Thread.sleep(randomNum); System.out.println(Thread.currentThread().getName() + ", 通过了第"+i+"个障碍物, 使用了 "+((double)randomNum/1000)+"s"); this.barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 总结：CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。]]></content>
      <categories>
        <category>java系列</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String StringBuilder StringBuffer]]></title>
    <url>%2F2021%2F02%2F16%2FString-StringBuilder-StringBuffer%2F</url>
    <content type="text"><![CDATA[String StringBuffer StringBuilder String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 可变类，速度更快 线程安全 线程不安全]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>对比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2021%2F02%2F16%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718/** * @author devin * @version 1.0.2 * @date 2021-02-16 23:23 */public class Zhenze &#123; // 待匹配字符串 public static void main(String[] args) &#123; String str = "湖北省武汉市1573rr4562"; Pattern p = Pattern.compile("[1-9]+"); Matcher m = p.matcher(str); while(m.find())&#123; System.out.println(m.group()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java系列</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝 浅拷贝解析]]></title>
    <url>%2F2021%2F02%2F15%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>java系列</category>
      </categories>
      <tags>
        <tag>java语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 爬取图片]]></title>
    <url>%2F2021%2F02%2F14%2Fpython-%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[思路分析： ​ requests 获得需要爬取的网页 ​ 将爬取的网页数据做成BeautifulSoup ​ 应用soup 的API 找到需要的标签属性 通过标签属性获得二进制字节保存 12345678910111213import requestsfrom bs4 import BeautifulSoupdata = requests.get("url")data.encoding = data.apparent_encodingsoup = BeautifulSoup(data.text)link = soup.select_one("#container &gt; div &gt; div &gt; div:nth-child(3) &gt; div.list_con_box &gt; div.zt_con_img &gt; dl &gt; dd &gt; ul &gt; li:nth-child(1) &gt; a &gt; img")['src']f = open("D://a.jpg","wb")pic_data = requests.get(link)f.write(pic_data.content)f.close()]]></content>
      <tags>
        <tag>是</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写数字识别]]></title>
    <url>%2F2021%2F02%2F14%2F%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[具体参考 https://www.cnblogs.com/endlesscoding/p/9901539.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120from sklearn.datasets import fetch_mldatafrom sklearn import datasetsimport numpy as np ## 样本可能下载超时mnist = fetch_mldata('mnist-original', data_home = './datasets/') mnistX, y = mnist['data'], mnist['target']print(X.shape)print(y.shape)%matplotlib inlineimport matplotlibimport matplotlib.pyplot as plt # 第一个样本some_digit = X[1]some_digit_image = some_digit.reshape(28,28) plt.imshow(some_digit_image, cmap=matplotlib.cm.binary, interpolation="nearest")plt.axis('off')plt.show()# EXTRA def plot_digits(instances, images_per_row=10, **options): size = 28 images_per_row = min(len(instances), images_per_row) images = [instance.reshape(size,size) for instance in instances] n_rows = (len(instances) - 1) // images_per_row + 1 row_images = [] n_empty = n_rows * images_per_row - len(instances) images.append(np.zeros((size, size * n_empty))) for row in range(n_rows): rimages = images[row * images_per_row : (row + 1) * images_per_row] row_images.append(np.concatenate(rimages, axis=1)) image = np.concatenate(row_images, axis=0) plt.imshow(image, cmap = matplotlib.cm.binary, **options) plt.axis("off") plt.figure(figsize=(9,9))example_images = np.r_[X[:12000:600], X[13000:30600:600], X[30600:60000:590]]plot_digits(example_images, images_per_row=10)# save_fig("more_digits_plot")plt.show()X_train, X_test, y_train, y_test = X[:60000],X[60000:],y[:60000],y[60000:]# 打乱标签import numpy as np shuffle_index = np.random.permutation(60000)X_train, y_train = X_train[shuffle_index],y_train[shuffle_index]# 训练一个二分器# 这是一个逻辑数组，5：True, 非5：Falsey_train_5 = (y_train == 5)y_test_5 = (y_test == 5)from sklearn.linear_model import SGDClassifier sgd_clf = SGDClassifier(random_state = 32)sgd_clf.fit(X_train, y_train_5)SGDClassifier(alpha=0.0001, average=False, class_weight=None, early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True, l1_ratio=0.15, learning_rate='optimal', loss='hinge', max_iter=None, n_iter=None, n_iter_no_change=5, n_jobs=None, penalty='l2', power_t=0.5, random_state=32, shuffle=True, tol=None, validation_fraction=0.1, verbose=0, warm_start=False)sgd_clf.predict([some_digit])array([ True])sgd_clf = SGDClassifier(random_state = 42)sgd_clf.fit(X_train, y_train_5)sgd_clf.predict([some_digit])from sklearn.model_selection import StratifiedKFoldfrom sklearn.base import clone # 使用交叉验证测量准确性skfolds = StratifiedKFold(n_splits = 3, random_state = 42)clone_clf = clone(sgd_clf)for train_index, test_index in skfolds.split(X_train, y_train_5): X_train_folds = X_train[train_index] y_train_folds = (y_train_5[train_index]) X_test_fold = X_train[test_index] y_test_fold = (y_train_5[test_index]) clone_clf.fit(X_train_folds, y_train_folds) y_pred = clone_clf.predict(X_test_fold) n_correct = sum(y_pred == y_test_fold) print(n_correct / len(y_pred)) from sklearn.model_selection import cross_val_scorecross_val_score(sgd_clf, X_train, y_train_5, cv = 3, scoring = "accuracy")from sklearn.base import BaseEstimator# 这个模型的预测的策略就是将所有的数据都认为是'非5'class Never5Classifier(BaseEstimator): def fit(self,X,y=None): pass def predict(self,X): return np.zeros((len(X),1), dtype=bool)never_5_clf = Never5Classifier()cross_val_score(never_5_clf, X_train, y_train_5, cv = 3, scoring = "accuracy")from sklearn.model_selection import cross_val_predict y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv = 3)]]></content>
      <tags>
        <tag>代码</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2021%2F02%2F14%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940/** * * @author devin * @date 2021-01-08 11:12 * @version 1.0.2*/public class SingleTest &#123; private static volatile SingleTest instance; private SingleTest()&#123; System.out.println("create method"); &#125; //在这里加同步太重 public static SingleTest getInstance()&#123; if(instance == null)&#123; synchronized (SingleTest.class)&#123; if(instance == null)&#123; return instance = new SingleTest(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; for(int i = 0;i &lt; 1000;i++)&#123; new Thread()&#123; @Override public void run() &#123; SingleTest.getInstance(); &#125; &#125;.start(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm参数调试demo]]></title>
    <url>%2F2021%2F02%2F13%2Fjvm%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95demo%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425/** * @author devin * @version 1.0.2 * @date 2021-01-13 20:48 */public class Demo2 &#123; private static final int _512KB = 512 * 1024; private static final int _1MB = 1024 * 1024; private static final int _6MB = 6 * 1024 * 1024; private static final int _7MB = 7 * 1024 * 1024; private static final int _8MB = 8 * 1024 * 1024; // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(3); queue.add(2); queue.add(3); queue.add(5); queue.put(3); System.out.println(queue.take()); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wait 释放锁]]></title>
    <url>%2F2021%2F02%2F13%2Fwait-%E9%87%8A%E6%94%BE%E9%94%81%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class ThreadB2 extends Thread &#123; /** * 线程 BBB 持有对象锁 this，即当前对象 threadB2 */ @Override public void run() &#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + " beg " + System.currentTimeMillis()); System.out.println("B2 ing"); System.out.println(Thread.currentThread().getName() + " end " + System.currentTimeMillis()); &#125; &#125;&#125;class ThreadA2 extends Thread &#123; private ThreadB2 threadB2; public ThreadA2(ThreadB2 threadB2) &#123; this.threadB2 = threadB2; &#125; /** * 线程 AAA 持有对象锁 threadB2 */ @Override public void run() &#123; //B2 被锁住 synchronized (threadB2) &#123; System.out.println(Thread.currentThread().getName() + " beg " + System.currentTimeMillis()); try &#123; System.out.println("wait之前：" + threadB2.isAlive()); threadB2.wait(); System.out.println("wait之后：" + threadB2.isAlive()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;// try &#123;// Thread.sleep(2000);// &#125; catch (InterruptedException e) &#123;// &#125; System.out.println(Thread.currentThread().getName() + " end " + System.currentTimeMillis()); &#125; &#125;&#125;class Run2 &#123; public static void main(String[] args) &#123; ThreadB2 threadB2 = new ThreadB2(); threadB2.setName("B2"); ThreadA2 threadA2 = new ThreadA2(threadB2); threadA2.setName("A2"); threadA2.start(); threadB2.start(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象锁]]></title>
    <url>%2F2021%2F02%2F13%2F%E5%AF%B9%E8%B1%A1%E9%94%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[notify 的使用]]></title>
    <url>%2F2021%2F02%2F13%2Fnotify-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435public class NotifyTest &#123; public synchronized void testWait()&#123; System.out.println(Thread.currentThread().getName() +" Start-----"); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +" End-------"); &#125; public static void main(String[] args) throws InterruptedException &#123; final NotifyTest test = new NotifyTest();// 创建五个线程取运行对象的方法 for(int i=0;i&lt;5;i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; test.testWait(); &#125; &#125;).start(); &#125; //通知一个 线程 synchronized (test) &#123; test.notify(); &#125; Thread.sleep(3000); System.out.println("-----------分割线-------------"); //通知所有线程 synchronized (test) &#123; test.notifyAll(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO通道的使用]]></title>
    <url>%2F2021%2F02%2F13%2FIO%E9%80%9A%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * * @author devin * @date 2021-01-07 15:52 * @version 1.0.2*/public class ChanTest &#123; private static FileOutputStream fileOutputStream; private static FileChannel fileChannel; public static &lt;buffer, buffer1, buffer2&gt; void main(String[] args) throws IOException, InterruptedException &#123; fileOutputStream = new FileOutputStream("D://out.txt"); fileChannel = fileOutputStream.getChannel(); for(int i = 0;i &lt; 10;i++)&#123; Thread thread1 = new Thread()&#123; @Override public void run() &#123; ByteBuffer buffer1 = ByteBuffer.wrap("123\r\n".getBytes()); try &#123; fileChannel.write(buffer1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread thread2 = new Thread()&#123; @Override public void run() &#123; ByteBuffer buffer2 = ByteBuffer.wrap("654\r\n".getBytes()); try &#123; fileChannel.write(buffer2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; Thread.sleep(3000); fileChannel.close(); fileOutputStream.close(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习一门知识]]></title>
    <url>%2F2021%2F02%2F13%2F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class BlockingQueueTest &#123; public static void main(String[] args) &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + "\t put A "); blockingQueue.put("A"); System.out.println(Thread.currentThread().getName() + "\t put B "); blockingQueue.put("B"); System.out.println(Thread.currentThread().getName() + "\t put C "); blockingQueue.put("C"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "t1").start(); new Thread(() -&gt; &#123; try &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; blockingQueue.take(); System.out.println(Thread.currentThread().getName() + "\t take A "); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; blockingQueue.take(); System.out.println(Thread.currentThread().getName() + "\t take B "); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; blockingQueue.take(); System.out.println(Thread.currentThread().getName() + "\t take C "); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "t2").start(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS 版本号应用]]></title>
    <url>%2F2021%2F02%2F13%2FCAS-%E7%89%88%E6%9C%AC%E5%8F%B7%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041/** * * @author devin * @date 2021-01-08 22:11 * @version 1.0.2*/public class MyUnsafe &#123; private static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;Integer&gt;(100,1); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println("t1拿到的初始版本号:" + atomicStampedReference.getStamp()); //睡眠1秒，是为了让t2线程也拿到同样的初始版本号 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; atomicStampedReference.compareAndSet(100, 101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); atomicStampedReference.compareAndSet(101, 100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1); &#125;,"t1").start(); new Thread(() -&gt; &#123; //得到共享变量的版本号 int stamp = atomicStampedReference.getStamp(); System.out.println("t2拿到的初始版本号:" + stamp); //睡眠3秒，是为了让t1线程完成ABA操作 try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("最新版本号:" + atomicStampedReference.getStamp()); //确认当前值 修改值 确认版本号 赋值新的版本号 获得修改后的值 修改成功与否 System.out.println(atomicStampedReference.compareAndSet(100, 2019,3,atomicStampedReference.getStamp() + 1) + "\t当前 值:" + atomicStampedReference.getReference()); &#125;,"t2").start(); &#125;&#125;]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用]]></title>
    <url>%2F2021%2F02%2F13%2Fhexo%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[新建一篇文章 123hexo new "博客名称"hexo new page --path about/me "About me" 部署博客 1234# 编译hexo g# 发布博客hexo d 启动服务器 1hexo server 多分类 12345categories:- Diarytags:- PS3- Games 分类和标签的使用规范 12分类：优先级 以领域划分 机器学习 生活 web开发 java系列标签：语言 读书笔记 代码 总结]]></content>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2021%2F01%2F28%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[异常 接口和抽象类 接口 接口的变量是默认是public static final 一个类可以实现多个接口 一个类实现接口必须实现接口的所有方法 可以多继承 抽象类 抽象可以有自己的变量 抽象类可以有自己的方法 可以包含静态方法 单继承 抽象的方法不需要全部实现 也就是适配器模式 异常 分为运行异常和检查异常 空指针异常 数组越界异常 IO异常 sql 异常 反射解释：通过类名获得类的方法和属性，它的产生是满足动态编译。 反射有三种方式 forName l类的class 对象的getClass 序列化(1)Java序列化就是指把Java对象转换为字节序列的过程 ​ Java反序列化就是指把字节序列恢复为Java对象的过程。 final finally finalizefinal 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源 请解释hashCode()和equals()方法有什么联系？相等的对象必须有相等的hashcode 有相同的hashcode 不一定相等 hash算法会有冲突 泛型擦除123456public class Foo &#123; public void listMethod(List&lt;String&gt; stringList)&#123; &#125; public void listMethod(List&lt;Integer&gt; intList) &#123; &#125;&#125; 报方法签名重复错误 List、List 擦除后的类型为 List。 List、List[] 擦除后的类型为 List[]。 List&lt;? extends E&gt;、List&lt;? super E&gt; 擦除后的类型为 List。 List&lt;T extends Serialzable &amp; Cloneable&gt; 擦除后类型为 List。 Java 为什么这么处理呢？有以下两个原因： 避免 JVM 的大换血。如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作了，提高了运行期的效率。版本兼容。 在编译期擦除可以更好地支持原生类型（Raw Type）。 明白了 Java 泛型是类型擦除的，下面的问题就很好理解了： 无法声明泛型数组1234567// 这种报错List&lt;String&gt;[] list = new List&lt;String&gt;[];List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); list1.add(2); list.add(list1); 泛型的理解​ 要理解泛型首先要立即泛型擦除，java字节码不包含泛型类型信息，使用泛型的时候会变编译器擦除，这个过程就叫泛型擦除。泛型的附加类型JVM是不可见的。它和C++的模板类型是有区别的 泛型是没有.class 对象 声明不同的泛型实例 泛型类只会被加载一次 1234ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); //jvm 只会加载一次ArrayList 泛型的参数类型不能用在java 处理异常中 ###]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java 死锁代码]]></title>
    <url>%2F2020%2F12%2F30%2FJAVA%E6%AD%BB%E9%94%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243package jvm;/** * @author devin * @version 1.0.2 * @date 2021-01-17 14:17 */import java.util.concurrent.TimeUnit;/** * 资源类 */class HoldLockThread implements Runnable&#123; private String lockA; private String lockB; // 持有自己的锁，还想得到别人的锁 public HoldLockThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + "\t 自己持有" + lockA + "\t 尝试获取：" + lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + "\t 自己持有" + lockB + "\t 尝试获取：" + lockA); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Es6 模块的导入和导出]]></title>
    <url>%2F2020%2F10%2F30%2Fes6%20%20%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[b.js 12345678export function fun()&#123; console.log("fun1")&#125;export let person = &#123; name:"devin", age:12&#125; c.js 12345678let a = 12let fun = function()&#123; console.log("function")&#125;export default&#123; a,fun&#125; index.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="module" &gt; // import * as util from './a.js'; // //import &#123;fun, person&#125; from "./a.js"; // console.log(util.fun(),util.person) // import a from './exportDefault'; // a.show(); // console.log(a.a); // import * as util from "./b.js" import c from "./c.js" // console.log(util.fun) console.log(c.a) c.fun() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序原生组件的坑]]></title>
    <url>%2F2020%2F09%2F30%2Fmpvue%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[style 1&lt;scroll-view :style="&#123;'height': '300px'&#125;"&gt;&lt;/scroll-view&gt;要设置高度 原生的事件 12345678910111213141516&lt;scroll-view :style="&#123;'height': '300px'&#125;" :scroll-y="true" @scrolltolower="scrolltolower" @scroll="scroll" &gt; &lt;div :style="&#123;'height': '200px','background-color':'red'&#125;"&gt;tyuiolpo&lt;/div&gt; &lt;div class="" :style="&#123;'height': '200px','background-color':'red'&#125;"&gt;dsdsd &lt;/div&gt;&lt;div class="" :style="&#123;'height': '200px','background-color':'red'&#125;"&gt;grytyju&lt;/div&gt;&lt;/scroll-view&gt; 数据部分 methods: &#123; scrolltolower()&#123; console.log(7) &#125;, scroll(e) &#123; console.log(6) console.log(e) &#125;, &#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习一门知识]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[两种学习方法 1.1 了解知识的产生背景，了解知识的大致框架，慢慢往里面填空。 1.2 做测试，错了给自己电击反馈 学习的一些技巧 2.1 确定学习的输入输出 2.2 康奈尔笔记法，学习的内容自己用自己的话复述出来，最后做个整体总结。]]></content>
      <categories>
        <category>哲学与生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas基本操作]]></title>
    <url>%2F2019%2F09%2F18%2Fpandas%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. pandas DataFrame对象的创建12dates = pd.date_range('20130101', periods=6)df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list('ABCD')) 2. 操作数据12345678910111213141516171819202122232425262728293031323334353637df.head()df.tail(3)df.indexdf.describe()# 单列索引df.iloc[1:2,2:]# 特定索引df.iloc[[1,2],[2,3]]# 布尔索引df[df&gt;0.5] = 1# 赋值列df2['E'] = ['A,','B','C','E','3','3']# 赋值行df2.loc['e'] = [1,2,3,4,5]#访问某个位置df2.iat[0,1]#删除带有缺失值的行df1.dropna(how = 'any')#填充空数据df1.fillna(value=5)# 获得每一列的平均值、df1.mean()# 获得每一行的平均值df1.mean(1)# 修改行标签df1.index = ['A','B','C']#修改行列data.rename(index=&#123;'A':'D', 'B':'E', 'C':'F'&#125;, columns=&#123;'a':'d','b':'e','c':'f'&#125;, inplace = True)#连接两个表pe = [df1,df2]pd.concat(pe)#数据库连接风格left = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'lval': [1, 2]&#125;)right = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'rval': [4, 5]&#125;)pd.merge(left, right, on='key')#写入文件df1.to_csv('foo.csv')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
